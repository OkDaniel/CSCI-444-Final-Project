---
title: "Group 9 – Esports vs Software Engineers"
author:
  - "Duy Nguyen – Esports Section"
  - "Bat-Orgil Erdenebat – Software Engineer Salary Section"
  - "Daniel Jimenez – Software Engineer Career / Experience Section"
date: "2025-11-21"
format:
  html:
    code-fold: true
    toc: true
  pdf:
    code-fold: true
    toc: true
execute:
  warning: false
  message: false
---

# Overall Introduction

Our project investigates how **esports professionals** compare to **software engineers** in terms of income, age, and career patterns. Esports is often seen as a short, intense career with high earnings for only a small number of players, while software engineering is usually described as a long term, stable profession.

Each member of **Group 9** is responsible for one part of this story:

- **Duy Nguyen** – *Esports section*: age and experience of esports players, game level earnings, and which games dominate the top earning professionals.
- **Bat-Orgil Erdenebat** – *Software engineer salary section* (US and state level maps, salary concentration).
- **Daniel Jimenez** – *Software engineer career and experience section* (career patterns, additional maps or widgets).

Together, these sections form a complete comparison between esports and software engineering careers.

```{r}
#| label: setup
# Global setup: load packages used across all questions

pacman::p_load(
  tidyverse,
  kableExtra,
  plotly,
  usmap,
  leaflet,
  maps,
  scales
)

theme_set(theme_minimal())
```

```{r}
#| label: load-esports-data
#| echo: true
# Load esports datasets for Duy's section

players <- readr::read_csv("data/esports_players_top1000_clean.csv")
team_perf <- readr::read_csv("data/esports_team_performance_clean.csv")
games <- readr::read_csv("data/general_esport_games_clean.csv")

glimpse(players)
glimpse(team_perf)
glimpse(games)
```

---

# Duy's Esports Section (Group 9)

**This section (coding and analysis) is written by: Duy Nguyen.**

Instructor feedback for **Group 9** asked us to:

- Compare **ages** of esports professionals and discuss how long it takes to “make it”.
- Look at different **esports games**, because some games might produce much higher earnings than others.
- Examine how long those games have been around and whether long running titles have an advantage.

For my part of the project I use:

- **Dataset 1 (scraped):** `esports_players_top1000_clean.csv` – top 1000 players by total earnings, scraped from *EsportsEarnings*.
- **Dataset 2 (Kaggle – age and experience):** `esports_team_performance_clean.csv` – team and player level statistics including age, experience, and performance.
- **Dataset 3 (Kaggle – game earnings):** `general_esport_games_clean.csv` – game level earnings and release years.

My section includes:

- A **histogram** and **bar chart** (ggplot),
- A **Plotly html widget** with a new feature (x axis range slider),
- A formatted **table using kableExtra**,
- And at least one dataset wrangled with **four different dplyr verbs** (`group_by`, `summarise`, `mutate`, `filter`).

---

## Question 1 – What is the typical age and experience profile of esports professionals?

**Question 1:**  
*What does the age and experience distribution look like for esports players in our Kaggle performance dataset, and what does this imply about the window when players tend to compete?*

We first summarise the age and experience of players, then visualise the age distribution and explore how age relates to performance.

### 1.1 Summary statistics for age and experience

```{r}
#| label: q1-summary
#| echo: true
# Question 1: summary statistics for player age and experience

q1_summary <- team_perf %>%
  summarise(
    mean_age          = mean(age_years, na.rm = TRUE),
    median_age        = median(age_years, na.rm = TRUE),
    min_age           = min(age_years, na.rm = TRUE),
    max_age           = max(age_years, na.rm = TRUE),
    mean_experience   = mean(experience_years, na.rm = TRUE),
    median_experience = median(experience_years, na.rm = TRUE)
  )

q1_summary
```

**Narrative (summary stats):**

These summary statistics show the typical age and years of experience for players in the dataset. In our sample, the average player is in the early twenties and almost everyone falls inside a fairly narrow ten year window. Experience is also concentrated, which suggests that esports professionals typically reach a high level quite quickly and do not spend decades in the scene.

### 1.2 Histogram of player ages

```{r}
#| label: q1-age-hist
#| echo: true
#| fig-cap: "Histogram of player ages in the Kaggle esports performance dataset"
# Question 1: visualise the distribution of player ages using a histogram

ggplot(team_perf, aes(x = age_years)) +
  geom_histogram(binwidth = 2, color = "white", fill = "#1f78b4") +
  labs(
    title = "Distribution of Esports Player Ages",
    x     = "Age (years)",
    y     = "Number of players"
  )
```

**Narrative (histogram):**

The histogram shows that most players are between roughly eighteen and twenty seven years old, with the tallest bars around the early twenties. There are almost no players far beyond the mid twenties, and the right tail drops off quickly. This fits the idea that reaction heavy esports favour younger competitors and that the competitive window is relatively short.

**Conclusion for Question 1 – age distribution:**

Overall, the age distribution suggests that esports careers are concentrated in the early adult years, with only a small number of older players still competing at a high level.

### 1.3 Plotly html widget – Age vs performance

```{r}
#| label: q1-plotly-age-performance
#| echo: true
#| fig-cap: "Interactive Plotly scatter plot of age vs performance, with experience shown by color"
# Question 1 (html widget): relationship between age and performance score
# New Plotly feature used: x axis range slider (not used in homework)

q1_plotly <- plot_ly(
  data  = team_perf,
  x     = ~age_years,
  y     = ~performance_score,
  color = ~experience_years,
  type  = "scatter",
  mode  = "markers",
  hoverinfo = "text",
  text = ~paste(
    "Age:", age_years,
    "<br>Experience (years):", experience_years,
    "<br>Win rate (%):", round(win_rate_pct, 1)
  )
) %>%
  layout(
    title = "Age vs Performance Score (colored by experience years)",
    xaxis = list(
      title      = "Age (years)",
      rangeslider = list(visible = TRUE)
    ),
    yaxis = list(title = "Performance score")
  )

q1_plotly
```

**Narrative (Plotly scatter):**

The interactive scatter plot lets us zoom in on different age ranges using the range slider. Points are coloured by years of experience, so older and more experienced players are easy to spot. Performance scores mostly fall in a middle range, and the densest cluster of strong scores appears in the early twenties age range for players with around five to seven years of experience. There are only a few points at older ages and they do not clearly outperform the younger group, which supports the idea that the peak of an esports career comes relatively early.

**Conclusion for Question 1 – age and performance:**

Combining the histogram and the scatter plot, Question 1 indicates that the esports career arc is compressed: players accumulate a few years of experience, reach high performance in their early twenties, and then relatively few remain in the top tier as they get older.

---

## Question 2 – Do older esports titles generate more total prize money?

**Question 2:**  
*Among major esports games, is there a relationship between how long a game has been around and the total prize money it has generated?*

We now turn to the game level Kaggle dataset, which contains total earnings and release years for a variety of esports titles.

### 2.1 Prepare data and summary for game age and earnings

```{r}
#| label: q2-game-summary
#| echo: true
# Question 2: prepare game level data with earnings in millions
# and compute overall summaries

games_q2 <- games %>%
  mutate(
    total_earnings_m = total_earnings_usd / 1e6
  )

games_q2 %>%
  summarise(
    n_games         = n(),
    mean_game_age   = mean(game_age_years, na.rm = TRUE),
    mean_earnings_m = mean(total_earnings_m, na.rm = TRUE),
    max_earnings_m  = max(total_earnings_m, na.rm = TRUE)
  )
```

**Narrative (summary for games):**

The summary shows that there are many different esports titles in this dataset. On average, a game has been out for more than a decade, with mean total prize money in the low millions of dollars. However, the maximum total prize pool is much larger, so prize money is clearly uneven. Looking at game age against total earnings helps us see whether older games systematically accumulate more money.

### 2.2 Scatterplot – Game age vs total earnings

```{r}
#| label: q2-age-vs-earnings
#| echo: true
#| fig-cap: "Relationship between game age and total earnings (in millions of USD)"
# Question 2: scatter plot of game age vs total earnings, with a smooth trend line

ggplot(games_q2, aes(x = game_age_years, y = total_earnings_m)) +
  geom_point(alpha = 0.7, color = "#1f78b4") +
  geom_smooth(method = "loess", se = FALSE, color = "#e31a1c") +
  labs(
    title = "Do Older Games Earn More Prize Money?",
    x     = "Game age (years since release)",
    y     = "Total earnings (millions of USD)"
  )
```

**Narrative (scatter):**

Each point represents a game, positioned by how long it has been out and how much total prize money it has generated. Most titles are clustered below twenty million dollars in total earnings, even when they have been around for ten to fifteen years. A small number of games stand out as clear outliers with much larger cumulative prize pools. The smooth trend line rises from very young games to middle aged titles and then flattens out, which suggests that time in the market helps but only a minority of games manage to convert longevity into very large prize pools.

### 2.3 kableExtra table – Top 10 games by total earnings

```{r}
#| label: q2-top-games-table
#| echo: true
#| results: "asis"
# Question 2: show the top 10 games by total prize money using kableExtra
# This satisfies the styled table requirement for Duy's section

top10_games <- games_q2 %>%
  arrange(desc(total_earnings_m)) %>%
  slice_head(n = 10) %>%
  select(
    game,
    release_year,
    game_age_years,
    total_earnings_m,
    total_players,
    total_tournaments
  )

top10_games %>%
  mutate(
    total_earnings_m = round(total_earnings_m, 2)
  ) %>%
  kbl(
    col.names = c(
      "Game", "Release year", "Game age (years)",
      "Total earnings (M USD)", "Total players", "Total tournaments"
    ),
    caption = "Top 10 esports titles by total prize money"
  ) %>%
  kable_paper(full_width = FALSE) %>%
  row_spec(1, bold = TRUE) %>%
  kable_styling(position = "center")
```

**Narrative (table):**

The table lists the ten games with the largest prize pools. A small set of titles produce very large cumulative earnings, while most other games have much smaller totals. These games are usually mature, which supports the idea that successful long running titles accumulate massive prize pools over time. At the same time, one or two newer titles can appear on the list, showing that a game with strong backing can catch up quickly.

**Conclusion for Question 2 – game age vs earnings:**

Overall, Question 2 suggests that time in the market matters: older games have had more opportunities to host tournaments and distribute prize money. However, success is not guaranteed; only certain titles translate longevity into sustained earnings.

---

## Question 3 – Which games dominate the top earning players?

**Question 3:**  
*Among the top 1000 highest earning players, which games appear most often and capture the largest share of total player earnings?*

Here we use the scraped EsportsEarnings dataset and create a pipeline with at least four dplyr verbs.

### 3.1 Four pipe wrangling: aggregate players by highest paying game

```{r}
#| label: q3-game-aggregation
#| echo: true
#| fig-cap: "Total earnings and player counts by highest paying game among the top 1000 players"
# Question 3: Which games dominate the top earning players?
# Pipeline with at least 4 dplyr verbs:
#   group_by(), summarise(), mutate(), filter() (arrange() is extra)
# Dataset: esports_players_top1000_clean.csv (scraped)

players_game_summary <- players %>%
  group_by(highest_paying_game) %>%
  summarise(
    n_players      = n(),
    total_earnings = sum(total_overall_usd, na.rm = TRUE),
    .groups        = "drop"
  ) %>%
  mutate(
    total_earnings_m = total_earnings / 1e6
  ) %>%
  filter(n_players >= 5) %>%
  arrange(desc(total_earnings_m))

players_game_summary
```

**Narrative (aggregated view):**

This table shows how many of the top 1000 players list each game as their highest paying title and how much total prize money those players have generated. A few games account for a very large share of earnings among the top players. The four step pipeline uses `group_by`, `summarise`, `mutate`, and `filter` to transform the scraped player data into a concise game level view that highlights this concentration.

### 3.2 Bar chart – Top games by total earnings (top 1000 players)

```{r}
#| label: q3-top-games-bar
#| echo: true
#| fig-cap: "Top games by total earnings among the top 1000 players (scraped data)"
# Question 3: bar chart of the top 10 games by total earnings

players_game_summary %>%
  slice_head(n = 10) %>%
  ggplot(aes(
    x = reorder(highest_paying_game, total_earnings_m),
    y = total_earnings_m
  )) +
  geom_col(fill = "#1f78b4") +
  coord_flip() +
  labs(
    title = "Top Games by Total Earnings (Top 1000 Players)",
    x     = "Game",
    y     = "Total earnings (millions of USD)"
  )
```

**Narrative (bar chart):**

The bar chart makes the concentration visually obvious. One game clearly leads in terms of total earnings among the top 1000 players, with its bar much longer than most other titles. The next group of games forms a second tier with substantial but noticeably smaller totals. Below that, earnings drop off quickly, so many games contribute only a small slice of the overall prize pool.

### 3.3 kableExtra table – Top 15 individual players

```{r}
#| label: q3-top-players-table
#| echo: true
#| results: "asis"
# Question 3: formatted table of the top 15 individual players by total earnings

top15_players <- players %>%
  arrange(desc(total_overall_usd)) %>%
  slice_head(n = 15) %>%
  mutate(
    total_overall_m = round(total_overall_usd / 1e6, 2),
    total_game_m    = round(total_game_usd / 1e6, 2)
  ) %>%
  select(
    rank,
    player_id,
    player_name,
    highest_paying_game,
    total_overall_m,
    total_game_m,
    pct_of_total_num
  )

top15_players %>%
  kbl(
    col.names = c(
      "Rank",
      "Player ID",
      "Player name",
      "Highest paying game",
      "Total earnings (M USD)",
      "Game earnings (M USD)",
      "Game % of total"
    ),
    caption = "Top 15 esports players by total career earnings (scraped from EsportsEarnings)"
  ) %>%
  kable_paper(full_width = FALSE) %>%
  kable_styling(position = "center") %>%
  column_spec(5:6, bold = TRUE)
```

**Narrative (top players table):**

The table lists individual players with the largest career earnings. The top earners each focus on a small set of games, and for almost all of them game specific earnings are essentially all of their total income. This reinforces the idea that earnings at the top of esports are not only concentrated in a few players but also in a few games. Switching games mid career could be risky if prize pools and competitive scenes differ greatly.

**Conclusion for Question 3 – domination of a few games:**

Question 3 shows that the earnings landscape is highly concentrated: a small set of games and a relatively small number of players capture a large fraction of total prize money. For an aspiring professional, this means that choosing which game to focus on is almost as important as individual skill.

---

# Overall Conclusion for Duy's Esports Section

Across my three questions, the esports data paints a consistent picture:

1. **Age and experience:**  
   Players in our dataset are mostly in their late teens and early twenties, with just a few years of experience. Performance seems to peak within this narrow window, which suggests that esports careers tend to be intense but short.

2. **Game age and prize money:**  
   Long running titles usually have higher cumulative prize pools, but only some games convert longevity into sustained earnings. A few successful titles dominate the market, while many others remain relatively small.

3. **Concentration among games and players:**  
   Among the top 1000 earners, prize money is heavily concentrated in a short list of games and a small group of players. Almost all of the biggest earners rely on one primary game for the majority of their income.

These results show that esports careers offer high potential rewards but also significant risk and a limited time window. In the full Group 9 report, my esports findings are compared with the software engineer sections to understand how these patterns differ from more traditional technical careers in terms of income stability, career length, and long term opportunities.

---

# Bat-Orgil's Software Engineer Salary Section (Group 9)

**This section (coding and analysis) is written by: Bat-Orgil Erdenebat.**

In our group project we compare the financial realities of two careers: professional esports and software engineering. My part focuses on the software engineer side. I use salary data for software developers in the United States to understand how pay is distributed and how concentrated the top earnings are.

My section is built around three related questions:

1. **Q1. How do median software engineer salaries vary across states in the United States.**
2. **Q2. How much of the total median salary mass is concentrated in the highest paying states.**
3. **Q3. What geographic patterns appear in software engineer pay levels, and how do different percentiles compare across states.**

These questions together help answer the group level question about how realistic and stable software engineer earnings are compared to the very concentrated prize money at the top of esports.

## Data and setup for software engineer salaries

In this project the salary data was scraped from O*NET and stored as `data/software_salaries_html_tables.csv`. In this section I read that data, clean the salary columns, and create a statewide summary that is reused in all visualizations.

```{r}
# Q0: load libraries for software engineer salary analysis
# Question context: This chunk supports Q1, Q2, and Q3 by loading required packages.
# Note: packages are already loaded in the global setup using pacman::p_load,
# but the library() calls are safe if run again.

library(tidyverse)
library(kableExtra)
library(scales)
library(usmap)
library(leaflet)
library(maps)
```

```{r}
# Q0: read and clean software engineer salary data for all states
# Question context: prepare a clean statewide salary table for Q1, Q2, and Q3.

salaries_raw <- read_csv(
  "data/software_salaries_html_tables.csv",
  show_col_types = FALSE
)

cleaned_salaries <- salaries_raw %>%
  mutate(
    P10    = parse_number(`Annual Low (10%)`),
    P25    = parse_number(`Annual QL (25%)`),
    Median = parse_number(`Annual Median (50%)`),
    P75    = parse_number(`Annual QU (75%)`),
    P90    = parse_number(`Annual High (90%)`),
    Location      = str_trim(Location),
    Location_Type = case_when(
      Location == "United States" ~ "National",
      Location == State_Name      ~ "Statewide",
      str_detect(Location, regex("nonmetropolitan", ignore_case = TRUE)) ~ "Non-metropolitan",
      TRUE                        ~ "Metropolitan"
    )
  ) %>%
  select(
    Location, Location_Type,
    State, State_Name,
    P10, P25, Median, P75, P90
  )

statewide_summary <- cleaned_salaries %>%
  filter(Location_Type == "Statewide") %>%
  mutate(
    state = State   # lowercase state abbreviation for usmap
  ) %>%
  select(
    state,          # required by usmap
    State,          # original abbreviation
    State_Name,
    P10, P25, Median, P75, P90
  ) %>%
  arrange(desc(Median))

head(statewide_summary)
```

This cleaning step converts salary percentiles to numeric values, classifies each record by location type, and produces a table with one row per state. The object `statewide_summary` is used in all three of my questions and in every visualization below.

---

## Question 1 – How do median salaries vary across states?

**Q1. How do median software engineer salaries vary across states in the United States.**

In this question I focus on how median salary levels differ from state to state. I use a bar chart to show the full distribution of medians across all states.

### Q1 visualization – Bar chart of median salary by state

```{r}
# Q1: bar chart of median software engineer salary by state
# Question 1: How do median salaries vary across states.

median_bar_plot <- statewide_summary %>%
  ggplot(aes(x = reorder(State_Name, Median), y = Median)) +
  geom_col() +
  coord_flip() +
  labs(
    title    = "Median software engineer salary by state",
    subtitle = "Statewide estimates from O*NET Online",
    x        = "State",
    y        = "Median salary (USD)"
  ) +
  scale_y_continuous(labels = dollar) +
  theme_minimal()

median_bar_plot
```

### Q1 narrative and conclusion

The bar chart shows that some states clearly pay more than others, but most states are in the same general range rather than being extremely low or extremely high. The ranking starts with states such as California and Washington near the top and moves down to lower paying states, but there is a smooth gradient instead of one or two extreme outliers. This suggests that software engineer salaries in the United States are spread across many states with reasonably strong median pay, rather than being limited to only one or two locations.

---

## Question 2 – How concentrated is income among the highest paying states?

**Q2. How much of the total median salary mass is concentrated in the highest paying states.**

In this question I study how much of the overall median salary is accounted for by the top states. I create a four pipe dplyr pipeline that ranks states by median salary and computes each state share and cumulative share of the total.

### Q2 wrangling – Four pipe concentration pipeline

```{r}
# Q2: compute rank and cumulative share of total median salary by state
# Question 2: How much of the total median salary mass is concentrated in the top states.
# This pipeline uses four different dplyr verbs: filter, arrange, mutate, and select.

salary_concentration <- statewide_summary %>%
  filter(!is.na(Median)) %>%
  arrange(desc(Median)) %>%
  mutate(
    rank      = row_number(),
    share     = Median / sum(Median),
    cum_share = cumsum(share)
  ) %>%
  select(State, State_Name, Median, rank, share, cum_share)

head(salary_concentration)
```

### Q2 visualization – kableExtra table of top states and their share

```{r}
# Q2: kableExtra table of top 10 states by median salary and income share
# Question 2: show how much of the total median salary is concentrated in the highest paying states.

salary_concentration %>%
  mutate(
    `Median salary (USD)` = dollar(Median),
    `Share of total`      = percent(share, accuracy = 0.1),
    `Cumulative share`    = percent(cum_share, accuracy = 0.1)
  ) %>%
  select(
    Rank = rank,
    State,
    State_Name,
    `Median salary (USD)`,
    `Share of total`,
    `Cumulative share`
  ) %>%
  slice(1:10) %>%
  kable(
    format  = "html",
    caption = "Top 10 states by median software engineer salary and share of total median pay",
    align   = "c"
  ) %>%
  kable_styling(
    full_width        = FALSE,
    bootstrap_options = c("striped", "hover", "condensed")
  ) %>%
  row_spec(0, bold = TRUE)
```

### Q2 narrative and conclusion

From this table we see that the highest paying states do not capture an extreme share of the total median salary mass. The cumulative share grows gradually: even after the top ten states, the cumulative share is still well below a majority of the total. This means that there is not a tiny group of states hoarding most of the earning power. For a student, this supports the idea that software engineering is a broadly accessible high paying career, rather than one where only a few locations provide serious income.

---

## Question 3 – What geographic patterns appear in pay levels and percentiles?

**Q3. What geographic patterns appear in software engineer pay levels, and how do different percentiles compare across states.**

In this question I look at how salaries vary across the map and how the lower and upper percentiles compare to the median. I use both a static US map and an interactive Leaflet widget to explore the geographic patterns.

### Q3 visualization 1 – US map of median salary by state

```{r}
# Q3: US map of median software engineer salary by state
# Question 3: What geographic patterns appear in software engineer pay levels.

us_salary_map <- plot_usmap(
  data    = statewide_summary,
  values  = "Median",
  regions = "states"
) +
  scale_fill_continuous(
    name  = "Median salary",
    label = dollar_format()
  ) +
  labs(
    title    = "Median software engineer salary by state",
    subtitle = "Statewide salary estimates from O*NET Online"
  ) +
  theme(legend.position = "right")

us_salary_map
```

### Q3 visualization 2 – Leaflet map with custom markers

```{r}
# Q3: Leaflet map of software engineer salaries with custom markers
# Question 3: How do different salary percentiles compare across states in a geographic view.

state_centers <- as.data.frame(state.center) %>%
  mutate(State_Name = state.name)

leaflet_data <- statewide_summary %>%
  left_join(state_centers, by = "State_Name")

leaflet(leaflet_data) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addAwesomeMarkers(
    lng  = ~x,
    lat  = ~y,
    icon = awesomeIcons(
      icon        = "briefcase",
      iconColor   = "white",
      markerColor = "blue",
      library     = "fa"
    ),
    popup = ~paste0(
      "<strong>", State_Name, "</strong><br>",
      "Median salary: ", dollar(Median), "<br>",
      "P10: ", dollar(P10), "<br>",
      "P90: ", dollar(P90)
    )
  )
```

### Q3 narrative and conclusion

The US map highlights clear regional patterns in median salaries. Some coastal and technology heavy states have higher median pay, while several interior states have lower values. However, high pay is not limited to one small region. Many states across the country show strong median salaries, which means there are diverse geographic options for a good software engineer income.

The Leaflet map adds more detail by showing the tenth and ninetieth percentile salaries in each state. In most places the P10 and P90 values are within a reasonable distance of the median, which means the spread of income inside each state is significant but not wildly extreme. This contrasts with esports prize earnings, where the top players can be many times above the typical competitor. In software engineering the range is more balanced, which suggests a more stable career path.

---

## Overall conclusion for the software engineer salary section

Across my three questions, the software engineer salary data shows a consistent story. Median salaries vary across states, but many locations offer strong pay. The highest paying states do not capture an overwhelming share of the total median salary mass, and geographic patterns show several regions with solid opportunities. Within states, lower and upper percentiles are not vastly different from the median compared to the extreme concentration seen in esports prize money.

For a student thinking about long term income, this suggests that software engineering provides a relatively stable and broadly accessible path to high earnings. When our group compares these results to the esports side of the project, the contrast in concentration and stability will help highlight how different the financial realities are between these two career choices.

# Daniel's Software Engineer Career & Cost-of-Living Section (Group 9)

**This section (coding + analysis) is written by: Daniel Jimenez.**

While Duy’s esports section focuses on prize money and short, intense careers, my section looks at the **software engineer side** of our comparison. Here, the focus is on:

-   How **software developer salaries** vary across U.S. metro areas
-   How much those salaries stretch after **cost of living and rent**
-   How stable and broad the opportunities are compared with the very concentrated esports earnings

I use the following dataset:

-   **Software developer income and expenses per U.S. metro** – `SofwareDeveloperIncomeExpensesperUSACity.csv`\
    This file includes adjusted and unadjusted software developer salaries, number of jobs, median home price, and several cost-of-living metrics for different metro areas.

```{r}
#| label: load-data-daniel
#| echo: true
# Daniel's dataset: software developer salary + cost of living by U.S. metro

sw <- readr::read_csv("data/SofwareDeveloperIncomeExpensesperUSACity.csv")

glimpse(sw)
```

## Question 4 – Which cities give software engineers the best "effective" pay?

**Question 4:**  *Which U.S. metro areas give software developers the best balance between salary and cost of living, and how different are the top cities from the rest?*

To answer this, I build a simple “effective pay” metric that compares adjusted software developer salary to cost of living plus rent. This tells us where developers get the most value for their income.

### 4.1 Four-pipe wrangling: compute effective pay and find top cities

```{r}
#| label: q4-effective-pay-wrangle
#| echo: true

# question 4: wrangle metro-level data to compute "effective pay"

# this pipeline uses 4+ dplyr verbs that count for the piping requirement:

# - mutate(), filter(), arrange(), group_by() + summarise() (for sanity check)

sw_effective <- sw %>%
mutate(
adj_salary = `Mean Software Developer Salary (adjusted)`,
col_rent   = `Cost of Living Plus Rent avg`,
effective_pay_index = adj_salary / col_rent
) %>%                                   # 1) mutate
filter(!is.na(effective_pay_index)) %>% # 2) filter
arrange(desc(effective_pay_index))      # 3) arrange

# sanity check by state: average effective pay per state (4) group_by + summarise

state_check <- sw_effective %>%
tidyr::separate(Metro, into = c("metro_name", "state_abbrev"), sep = ", ") %>%
group_by(state_abbrev) %>%
summarise(
mean_effective_pay = mean(effective_pay_index, na.rm = TRUE),
.groups = "drop"
)

head(sw_effective)
```

### 4.2 Bar chart – Top 10 metros by effective pay

```{r}
#| label: q4-effective-pay-bar
#| echo: true
#| fig-cap: "Top 10 U.S. metros where software developer pay stretches the furthest after cost of living and rent"

# question 4: bar chart of top 10 metros by effective pay index

sw_effective %>%
slice_head(n = 10) %>%
ggplot(aes(
x = reorder(Metro, effective_pay_index),
y = effective_pay_index
)) +
geom_col(fill = "#1f78b4") +
coord_flip() +
labs(
title = "Top 10 Metros by Effective Software Developer Pay",
x = "Metro area",
y = "Effective pay index\n(adjusted salary / cost of living + rent)"
)
```

**Narrative: The top metros provide strong adjusted salaries relative to living costs. Unlike esports, where only a tiny group achieves high earnings, software engineers have multiple cities offering strong financial outcomes.**

## Question 5 – How does cost of living trade off with salary?

**Question 5:**  *Do the highest-paying metros always have the best cost of living, or is there a trade-off between salary level and day-to-day expenses?*

### 5.1 Scatterplot – Salary vs cost of living

```{r}
#| label: q5-salary-vs-col
#| echo: true
#| fig-cap: "Relationship between adjusted software developer salary and cost of living plus rent by metro"

# question 5: scatter plot of salary vs cost of living

ggplot(sw, aes(
x = `Cost of Living Plus Rent avg`,
y = `Mean Software Developer Salary (adjusted)`
)) +
geom_point(alpha = 0.7, color = "#1f78b4") +
labs(
title = "Do Higher Salaries Always Beat High Living Costs?",
x = "Cost of living + rent (index)",
y = "Adjusted software developer salary (USD)"
)
```

### 5.2 Histogram – Distribution of adjusted salaries

```{r}
#| label: q5-salary-hist
#| echo: true
#| fig-cap: "Histogram of adjusted software developer salaries across U.S. metros"

# question 5: histogram of adjusted software developer salaries

ggplot(sw, aes(x = `Mean Software Developer Salary (adjusted)`)) +
geom_histogram(binwidth = 5000, color = "white", fill = "#33a02c") +
labs(
title = "Distribution of Adjusted Software Developer Salaries",
x = "Adjusted software developer salary (USD)",
y = "Number of metros"
)
```

## Question 6 – How far ahead are software developers compared to typical workers?

**Question 6:**  *By how much do software developer salaries beat the average salary for all occupations in a metro, and which cities offer the biggest gap?*

### 6.1 Compute salary advantage vs all occupations (table)

```{r}
#| label: q6-advantage-wrangle
#| echo: true
#| results: "asis"

sw_advantage <- sw %>%
mutate(
dev_salary_unadj = `Mean Software Developer Salary (unadjusted)`,
all_occ_salary   = `Mean Unadjusted Salary (all occupations)`,
salary_advantage = dev_salary_unadj - all_occ_salary,
salary_ratio     = dev_salary_unadj / all_occ_salary
) %>%
arrange(desc(salary_advantage))

top10_advantage <- sw_advantage %>%
slice_head(n = 10) %>%
select(
Metro,
dev_salary_unadj,
all_occ_salary,
salary_advantage,
salary_ratio
)

top10_advantage %>%
mutate(
dev_salary_unadj = round(dev_salary_unadj, 0),
all_occ_salary   = round(all_occ_salary, 0),
salary_advantage = round(salary_advantage, 0),
salary_ratio     = round(salary_ratio, 2)
) %>%
kbl(
col.names = c(
"Metro",
"Developer salary (USD)",
"All-occupation salary (USD)",
"Advantage (USD)",
"Developer / All-occupation ratio"
),
caption = "Top 10 metros where software developers earn the most above the average worker"
) %>%
kable_paper(full_width = FALSE) %>%
kable_styling(position = "center") %>%
column_spec(4, bold = TRUE)
```

### 6.2 Plotly html widget – Salary advantage vs number of jobs

```{r}
#| label: q6-advantage-plotly
#| echo: true
#| fig-cap: "Interactive Plotly scatter of salary advantage vs number of developer jobs"

q6_plotly <- plotly::plot_ly(
data = sw_advantage,
x = ~`Number of Software Developer Jobs`,
y = ~salary_advantage,
type = "scatter",
mode = "markers",
size = ~`Number of Software Developer Jobs`,
sizemode = "area",
sizeref = 2 * max(sw_advantage$`Number of Software Developer Jobs`, na.rm = TRUE) / 100^2,
hovertemplate = paste(
"<b>%{text}</b><br>",
"Jobs: %{x}<br>",
"Salary advantage: $%{y:.0f}<extra></extra>"
),
text = ~Metro
) %>%
layout(
title = "Where Do High-Paying Developer Jobs Cluster?",
xaxis = list(
title = "Number of software developer jobs",
rangeslider = list(visible = TRUE)
),
yaxis = list(
title = "Developer salary advantage vs all occupations (USD)"
)
)

q6_plotly
```

# Overall Conclusion for Daniel's Software Engineer Section

**Software engineering shows:**

**1.** Many cities with strong income after cost of living

**2.** Stable, predictable salaries rather than esports volatility

**3.** A consistent salary premium over typical workers

**4.** A career path that lasts 25–35 years, not a 5–7 year peak window

Together, these findings help explain why SWE is a long-term, stable career, in contrast with the high-risk, short-window earning structure of esports.

